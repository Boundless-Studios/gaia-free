"""API routes for scene image management.

Provides endpoints for retrieving scene image sets generated by the
Visual Narrator agent. These endpoints allow the frontend to:
- Get the latest scene image set for a campaign
- Get a specific image set by ID
- Check the generation status of an image set
"""

import logging
from typing import Any, Dict, List, Optional

from fastapi import APIRouter, HTTPException, Query
from pydantic import BaseModel

from gaia.infra.image.scene_image_set import get_scene_image_set_manager

logger = logging.getLogger(__name__)

# Create router
router = APIRouter(prefix="/api/scene-images", tags=["scene-images"])


# Response models
class SceneImageResponse(BaseModel):
    """Individual scene image in a set."""

    type: str
    description: str
    status: str
    image_url: Optional[str] = None
    image_path: Optional[str] = None
    error: Optional[str] = None
    generated_at: Optional[str] = None


class SceneImageSetResponse(BaseModel):
    """Response model for a scene image set."""

    set_id: str
    campaign_id: str
    turn_number: int
    status: str
    created_at: str
    completed_at: Optional[str] = None
    images: List[SceneImageResponse]


class SceneImageSetListResponse(BaseModel):
    """Response model for a list of scene image sets."""

    sets: List[SceneImageSetResponse]
    total: int


@router.get("/latest", response_model=Optional[SceneImageSetResponse])
async def get_latest_scene_images(
    campaign_id: str = Query(..., description="Campaign ID to get latest images for"),
) -> Optional[Dict[str, Any]]:
    """Get the most recent scene image set for a campaign.

    Args:
        campaign_id: The campaign to get images for

    Returns:
        The latest SceneImageSet if any exist, null otherwise
    """
    manager = get_scene_image_set_manager()
    image_set = manager.get_latest_set(campaign_id)

    if not image_set:
        return None

    return image_set.to_dict()


@router.get("/campaign/{campaign_id}", response_model=SceneImageSetListResponse)
async def get_campaign_scene_images(
    campaign_id: str,
    limit: int = Query(5, ge=1, le=20, description="Maximum number of sets to return"),
) -> Dict[str, Any]:
    """Get recent scene image sets for a campaign.

    Args:
        campaign_id: The campaign to get images for
        limit: Maximum number of sets to return (1-20)

    Returns:
        List of recent SceneImageSets, most recent first
    """
    manager = get_scene_image_set_manager()
    sets = manager.get_campaign_sets(campaign_id, limit=limit)

    return {
        "sets": [s.to_dict() for s in sets],
        "total": len(sets),
    }


@router.get("/{set_id}", response_model=SceneImageSetResponse)
async def get_scene_image_set(
    set_id: str,
) -> Dict[str, Any]:
    """Get a specific scene image set by ID.

    Args:
        set_id: The set ID to retrieve

    Returns:
        The SceneImageSet

    Raises:
        HTTPException: 404 if set not found
    """
    manager = get_scene_image_set_manager()
    image_set = manager.get_set(set_id)

    if not image_set:
        raise HTTPException(status_code=404, detail=f"Scene image set {set_id} not found")

    return image_set.to_dict()


@router.get("/{set_id}/status")
async def get_scene_image_set_status(
    set_id: str,
) -> Dict[str, Any]:
    """Get the generation status of a scene image set.

    This is a lightweight endpoint for polling status without
    fetching full image data.

    Args:
        set_id: The set ID to check

    Returns:
        Status information including overall status and per-image status

    Raises:
        HTTPException: 404 if set not found
    """
    manager = get_scene_image_set_manager()
    image_set = manager.get_set(set_id)

    if not image_set:
        raise HTTPException(status_code=404, detail=f"Scene image set {set_id} not found")

    return {
        "set_id": image_set.set_id,
        "status": image_set.status,
        "created_at": image_set.created_at.isoformat(),
        "completed_at": image_set.completed_at.isoformat() if image_set.completed_at else None,
        "image_statuses": {
            img.image_type: {
                "status": img.status,
                "has_url": bool(img.image_url),
            }
            for img in image_set.images
        },
    }
