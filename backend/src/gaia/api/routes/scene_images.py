"""API routes for scene image management.

Provides endpoints for retrieving scene image sets generated by the
Visual Narrator agent. These endpoints allow the frontend to:
- Get the latest scene image set for a campaign
- Get a specific image set by ID
- Check the generation status of an image set
- Create composite images from scene image sets
"""

import logging
from io import BytesIO
from typing import Any, Dict, List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query, Request
from PIL import Image
from pydantic import BaseModel
from sqlalchemy import func, select
from sqlalchemy.ext.asyncio import AsyncSession

from auth.src.flexible_auth import optional_auth
from auth.src.models import AccessControl, PermissionLevel, User
from db.src import get_async_db
from gaia.infra.image.image_artifact_store import ImageStorageType, image_artifact_store
from gaia.infra.image.image_metadata import get_metadata_manager
from gaia.infra.image.scene_image_set import ImageType, get_scene_image_set_manager

logger = logging.getLogger(__name__)

# Create router
router = APIRouter(prefix="/api/scene-images", tags=["scene-images"])


async def check_campaign_access(
    campaign_id: str,
    current_user: Optional[User],
    request: Request,
    db: AsyncSession,
) -> bool:
    """Check if the current user has access to the specified campaign.

    Args:
        campaign_id: The campaign ID to check access for
        current_user: The authenticated user (may be None in dev mode)
        request: The FastAPI request object
        db: The async database session

    Returns:
        True if authorized, False otherwise
    """
    # In dev mode without auth, allow access
    if current_user is None:
        return True

    # Check session registry first (for active sessions)
    authorized = False
    session_registry = getattr(request.app.state, "session_registry", None)
    if session_registry:
        try:
            authorized = session_registry.is_authorized(
                campaign_id,
                user_id=getattr(current_user, "user_id", None),
                user_email=getattr(current_user, "email", None),
            )
        except Exception:
            authorized = False

    # If not authorized via session registry, check database ACL
    if not authorized:
        stmt = (
            select(func.count())
            .select_from(AccessControl)
            .where(
                AccessControl.resource_type == "campaign",
                AccessControl.resource_id == campaign_id,
                AccessControl.user_id == current_user.user_id,
                AccessControl.permission_level.in_(
                    [
                        PermissionLevel.READ.value,
                        PermissionLevel.WRITE.value,
                        PermissionLevel.ADMIN.value,
                    ]
                ),
            )
        )
        result = await db.execute(stmt)
        authorized = (result.scalar_one() or 0) > 0

    return authorized


# Response models
class SceneImageResponse(BaseModel):
    """Individual scene image in a set."""

    type: str
    description: str
    status: str
    image_url: Optional[str] = None
    image_path: Optional[str] = None
    error: Optional[str] = None
    generated_at: Optional[str] = None


class SceneImageSetResponse(BaseModel):
    """Response model for a scene image set."""

    set_id: str
    campaign_id: str
    turn_number: int
    status: str
    created_at: str
    completed_at: Optional[str] = None
    images: List[SceneImageResponse]


class SceneImageSetListResponse(BaseModel):
    """Response model for a list of scene image sets."""

    sets: List[SceneImageSetResponse]
    total: int


@router.get("/latest", response_model=Optional[SceneImageSetResponse])
async def get_latest_scene_images(
    request: Request,
    campaign_id: str = Query(..., description="Campaign ID to get latest images for"),
    current_user: Optional[User] = optional_auth(),
    db: AsyncSession = Depends(get_async_db),
) -> Optional[Dict[str, Any]]:
    """Get the most recent scene image set for a campaign.

    Args:
        request: The FastAPI request object
        campaign_id: The campaign to get images for
        current_user: The authenticated user (optional in dev mode)
        db: The async database session

    Returns:
        The latest SceneImageSet if any exist, null otherwise

    Raises:
        HTTPException: 403 if not authorized to access the campaign
    """
    if not await check_campaign_access(campaign_id, current_user, request, db):
        raise HTTPException(
            status_code=403,
            detail="Not authorized to access this campaign's images",
        )

    manager = get_scene_image_set_manager()
    image_set = manager.get_latest_set(campaign_id)

    if not image_set:
        return None

    return image_set.to_dict()


@router.get("/campaign/{campaign_id}", response_model=SceneImageSetListResponse)
async def get_campaign_scene_images(
    request: Request,
    campaign_id: str,
    limit: int = Query(5, ge=1, le=20, description="Maximum number of sets to return"),
    current_user: Optional[User] = optional_auth(),
    db: AsyncSession = Depends(get_async_db),
) -> Dict[str, Any]:
    """Get recent scene image sets for a campaign.

    Args:
        request: The FastAPI request object
        campaign_id: The campaign to get images for
        limit: Maximum number of sets to return (1-20)
        current_user: The authenticated user (optional in dev mode)
        db: The async database session

    Returns:
        List of recent SceneImageSets, most recent first

    Raises:
        HTTPException: 403 if not authorized to access the campaign
    """
    if not await check_campaign_access(campaign_id, current_user, request, db):
        raise HTTPException(
            status_code=403,
            detail="Not authorized to access this campaign's images",
        )

    manager = get_scene_image_set_manager()
    sets = manager.get_campaign_sets(campaign_id, limit=limit)

    return {
        "sets": [s.to_dict() for s in sets],
        "total": len(sets),
    }


@router.get("/{set_id}", response_model=SceneImageSetResponse)
async def get_scene_image_set(
    request: Request,
    set_id: str,
    current_user: Optional[User] = optional_auth(),
    db: AsyncSession = Depends(get_async_db),
) -> Dict[str, Any]:
    """Get a specific scene image set by ID.

    Args:
        request: The FastAPI request object
        set_id: The set ID to retrieve
        current_user: The authenticated user (optional in dev mode)
        db: The async database session

    Returns:
        The SceneImageSet

    Raises:
        HTTPException: 404 if set not found, 403 if not authorized
    """
    manager = get_scene_image_set_manager()
    image_set = manager.get_set(set_id)

    if not image_set:
        raise HTTPException(status_code=404, detail=f"Scene image set {set_id} not found")

    # Check authorization against the campaign this set belongs to
    if not await check_campaign_access(image_set.campaign_id, current_user, request, db):
        raise HTTPException(
            status_code=403,
            detail="Not authorized to access this campaign's images",
        )

    return image_set.to_dict()


@router.get("/{set_id}/status")
async def get_scene_image_set_status(
    request: Request,
    set_id: str,
    current_user: Optional[User] = optional_auth(),
    db: AsyncSession = Depends(get_async_db),
) -> Dict[str, Any]:
    """Get the generation status of a scene image set.

    This is a lightweight endpoint for polling status without
    fetching full image data.

    Args:
        request: The FastAPI request object
        set_id: The set ID to check
        current_user: The authenticated user (optional in dev mode)
        db: The async database session

    Returns:
        Status information including overall status and per-image status

    Raises:
        HTTPException: 404 if set not found, 403 if not authorized
    """
    manager = get_scene_image_set_manager()
    image_set = manager.get_set(set_id)

    if not image_set:
        raise HTTPException(status_code=404, detail=f"Scene image set {set_id} not found")

    # Check authorization against the campaign this set belongs to
    if not await check_campaign_access(image_set.campaign_id, current_user, request, db):
        raise HTTPException(
            status_code=403,
            detail="Not authorized to access this campaign's images",
        )

    return {
        "set_id": image_set.set_id,
        "status": image_set.status,
        "created_at": image_set.created_at.isoformat(),
        "completed_at": image_set.completed_at.isoformat() if image_set.completed_at else None,
        "image_statuses": {
            img.image_type: {
                "status": img.status,
                "has_url": bool(img.image_url),
            }
            for img in image_set.images
        },
    }


# Composite image endpoint
class CompositeImageResponse(BaseModel):
    """Response model for composite image creation."""

    success: bool
    composite_url: Optional[str] = None
    message: str


@router.post("/{set_id}/composite", response_model=CompositeImageResponse)
async def create_composite_image(
    request: Request,
    set_id: str,
    current_user: Optional[User] = optional_auth(),
    db: AsyncSession = Depends(get_async_db),
) -> Dict[str, Any]:
    """Create a horizontal 3x1 composite image from a scene image set.

    Combines the three scene images (location, background, moment) into
    a single horizontal composite image for display to players.

    Args:
        request: The FastAPI request object
        set_id: The scene image set to create composite from
        current_user: The authenticated user (optional in dev mode)
        db: The async database session

    Returns:
        CompositeImageResponse with the URL to the composite image

    Raises:
        HTTPException: 404 if set not found, 403 if not authorized,
                       400 if no images available
    """
    manager = get_scene_image_set_manager()
    image_set = manager.get_set(set_id)

    if not image_set:
        raise HTTPException(status_code=404, detail=f"Scene image set {set_id} not found")

    # Check authorization
    if not await check_campaign_access(image_set.campaign_id, current_user, request, db):
        raise HTTPException(
            status_code=403,
            detail="Not authorized to access this campaign's images",
        )

    # Collect complete images in order: location, background, moment
    image_order = [
        ImageType.LOCATION_AMBIANCE.value,
        ImageType.BACKGROUND_DETAIL.value,
        ImageType.MOMENT_FOCUS.value,
    ]

    pil_images = []
    for img_type in image_order:
        img = image_set.get_image(img_type)
        if img and img.status == "complete" and img.image_url:
            try:
                # Extract session_id and filename from the image URL
                # URL format: /api/images/media/images/{session_id}/{type}s/{filename}
                url_parts = img.image_url.strip("/").split("/")
                # Find the session_id (e.g., campaign_XX)
                session_id = image_set.campaign_id
                filename = url_parts[-1] if url_parts else None

                if filename:
                    img_bytes = image_artifact_store.read_artifact_bytes(session_id, filename)
                    pil_img = Image.open(BytesIO(img_bytes))
                    pil_images.append(pil_img)
                    logger.debug(f"Loaded image for composite: {img_type}")
            except Exception as exc:
                logger.warning(f"Failed to load image {img_type} for composite: {exc}")

    if not pil_images:
        return {
            "success": False,
            "composite_url": None,
            "message": "No completed images available to create composite",
        }

    # Create horizontal composite
    # Resize all images to same height while maintaining aspect ratio
    target_height = 512
    resized_images = []
    for img in pil_images:
        # Convert to RGB if needed (in case of RGBA/P mode)
        if img.mode in ("RGBA", "P"):
            img = img.convert("RGB")

        aspect = img.width / img.height
        new_width = int(target_height * aspect)
        resized = img.resize((new_width, target_height), Image.Resampling.LANCZOS)
        resized_images.append(resized)

    # Calculate total width and create composite
    total_width = sum(img.width for img in resized_images)
    composite = Image.new("RGB", (total_width, target_height))

    # Paste images side by side
    x_offset = 0
    for img in resized_images:
        composite.paste(img, (x_offset, 0))
        x_offset += img.width

    # Save composite using image artifact store
    output = BytesIO()
    composite.save(output, format="PNG", optimize=True)
    output.seek(0)

    artifact = image_artifact_store.persist_image(
        session_id=image_set.campaign_id,
        image_bytes=output.getvalue(),
        image_type="scene",
        filename=f"composite_{set_id}.png",
    )

    logger.info(
        f"Created composite image for set {set_id}: {artifact.url} "
        f"({len(pil_images)} images, {total_width}x{target_height})"
    )

    # Save metadata so the image appears in the media gallery
    try:
        metadata_manager = get_metadata_manager()
        metadata_manager.save_metadata(
            image_filename=f"composite_{set_id}.png",
            metadata={
                "prompt": "Scene Composite",
                "type": "scene",
                "storage_filename": f"composite_{set_id}.png",
                "storage_path": artifact.storage_path,
                "proxy_url": artifact.url,
                "set_id": set_id,
            },
            campaign_id=image_set.campaign_id,
        )
        logger.info(f"Saved metadata for composite image {set_id}")
    except Exception as meta_error:
        logger.warning(f"Failed to save composite metadata: {meta_error}")

    # Broadcast the composite image to all players via WebSocket
    try:
        from gaia.connection.socketio_broadcaster import socketio_broadcaster

        await socketio_broadcaster.broadcast_image_generated(
            session_id=image_set.campaign_id,
            image_data={
                "url": artifact.url,
                "local_path": artifact.storage_path or f"composite_{set_id}.png",
                "prompt": "Scene Composite",
                "type": "scene",
            },
        )
        logger.info(f"Broadcasted composite image to players for campaign {image_set.campaign_id}")
    except Exception as broadcast_error:
        logger.warning(f"Failed to broadcast composite image: {broadcast_error}")

    return {
        "success": True,
        "composite_url": artifact.url,
        "message": f"Created composite from {len(pil_images)} images",
    }


# Test/Debug endpoints
class TestGenerateRequest(BaseModel):
    """Request model for test scene image generation."""

    campaign_id: str
    scene_description: str
    turn_number: int = 1


class TestGenerateResponse(BaseModel):
    """Response model for test generation."""

    success: bool
    set_id: Optional[str] = None
    message: str
    descriptions: Optional[Dict[str, str]] = None


@router.post("/test-generate", response_model=TestGenerateResponse)
async def test_generate_scene_images(
    http_request: Request,
    request: TestGenerateRequest,
    current_user: Optional[User] = optional_auth(),
    db: AsyncSession = Depends(get_async_db),
) -> Dict[str, Any]:
    """Debug endpoint to trigger scene image generation.

    This endpoint creates a scene image set and triggers async image generation
    for testing the Visual Narrator pipeline.

    Args:
        http_request: The FastAPI request object
        request: Contains campaign_id, scene_description, and turn_number
        current_user: The authenticated user (optional in dev mode)
        db: The async database session

    Returns:
        Success status and set_id for polling

    Raises:
        HTTPException: 403 if not authorized to access the campaign
    """
    import asyncio

    # Check authorization for the campaign
    if not await check_campaign_access(request.campaign_id, current_user, http_request, db):
        raise HTTPException(
            status_code=403,
            detail="Not authorized to generate images for this campaign",
        )

    logger.info(
        f"ðŸŽ¨ [DEBUG] Test scene image generation triggered: "
        f"campaign={request.campaign_id}, turn={request.turn_number}"
    )

    try:
        # Import the visual narrator agent
        from gaia_private.agents.scene.visual_narrator_agent import (
            VisualNarratorAgent,
        )

        # Create agent and build context
        agent = VisualNarratorAgent()

        # Build a minimal analysis context from the scene description
        analysis_context = {
            "previous_scenes": [{"narrative": request.scene_description}],
            "active_characters": [],
            "current_turn": {"character_name": "Test Character"},
        }

        # Run the visual narrator to get descriptions
        logger.info("ðŸŽ¨ [DEBUG] Running visual narrator agent...")
        result = await agent.generate_visual_descriptions(
            user_input=request.scene_description,
            analysis_context=analysis_context,
        )

        if not result or not any(
            [result.location_ambiance, result.background_detail, result.moment_focus]
        ):
            return {
                "success": False,
                "message": "Visual narrator returned empty descriptions",
                "set_id": None,
                "descriptions": None,
            }

        descriptions = result.to_dict()
        logger.info(f"ðŸŽ¨ [DEBUG] Visual narrator descriptions: {descriptions}")

        # Create a scene image set
        manager = get_scene_image_set_manager()
        image_set = manager.create_set(
            campaign_id=request.campaign_id,
            turn_number=request.turn_number,
            descriptions={
                "location_ambiance": result.location_ambiance or "",
                "background_detail": result.background_detail or "",
                "moment_focus": result.moment_focus or "",
            },
        )

        logger.info(f"ðŸŽ¨ [DEBUG] Created scene image set: {image_set.set_id}")

        # Parallel image generation using the Runware client pool
        async def run_all_generations_with_pool():
            """Run all image generations in parallel using the client pool."""
            from gaia.infra.image.image_service_manager import get_image_service_manager

            logger.info("ðŸŽ¨ [DEBUG] Starting parallel image generation with pool...")

            # Map scene ImageType to storage ImageStorageType
            style_map = {
                ImageType.LOCATION_AMBIANCE.value: ImageStorageType.SCENE.value,
                ImageType.BACKGROUND_DETAIL.value: ImageStorageType.SCENE_BACKGROUND.value,
                ImageType.MOMENT_FOCUS.value: ImageStorageType.MOMENT.value,
            }

            # Build requests for parallel generation
            generation_requests = []
            image_types = []

            for img_type, description in [
                ("location_ambiance", result.location_ambiance),
                ("background_detail", result.background_detail),
                ("moment_focus", result.moment_focus),
            ]:
                if description:
                    generation_requests.append({
                        "prompt": description,
                        "width": 1024,
                        "height": 1024,
                    })
                    image_types.append(img_type)
                else:
                    # Mark as failed immediately if no description
                    manager.update_image(
                        set_id=image_set.set_id,
                        image_type=img_type,
                        status="failed",
                        error="No description provided",
                    )

            if not generation_requests:
                logger.warning("ðŸŽ¨ [DEBUG] No valid descriptions for image generation")
                return

            # Generate all images in parallel using the pool
            image_manager = get_image_service_manager()
            results = await image_manager.generate_images_parallel(generation_requests)

            # Process results and update the scene image set
            for img_type, gen_result in zip(image_types, results):
                if gen_result.get("success"):
                    # Get the image URL from the result
                    images = gen_result.get("images", [])
                    if images:
                        img_data = images[0]
                        # Save the image and get URL
                        from gaia.infra.image.image_artifact_store import image_artifact_store

                        if "b64_json" in img_data:
                            import base64
                            img_bytes = base64.b64decode(img_data["b64_json"])
                            artifact = image_artifact_store.persist_image(
                                session_id=request.campaign_id,
                                image_bytes=img_bytes,
                                image_type=style_map.get(img_type, "scene"),
                                filename=f"{img_type}_{image_set.set_id}.png",
                            )
                            manager.update_image(
                                set_id=image_set.set_id,
                                image_type=img_type,
                                status="complete",
                                image_url=artifact.url,
                                image_path=artifact.local_path,
                            )
                            logger.info(f"ðŸŽ¨ [DEBUG] Generated {img_type} image successfully")
                        else:
                            manager.update_image(
                                set_id=image_set.set_id,
                                image_type=img_type,
                                status="failed",
                                error="No image data in result",
                            )
                    else:
                        manager.update_image(
                            set_id=image_set.set_id,
                            image_type=img_type,
                            status="failed",
                            error="No images returned",
                        )
                else:
                    manager.update_image(
                        set_id=image_set.set_id,
                        image_type=img_type,
                        status="failed",
                        error=gen_result.get("error", "Unknown error"),
                    )
                    logger.warning(
                        f"ðŸŽ¨ [DEBUG] Failed to generate {img_type}: "
                        f"{gen_result.get('error')}"
                    )

            logger.info("ðŸŽ¨ [DEBUG] All image generations completed")

        # Start async generation for all image types (fire and forget)
        # Use the pool-based parallel generation
        asyncio.create_task(run_all_generations_with_pool())

        return {
            "success": True,
            "set_id": image_set.set_id,
            "message": "Scene image generation started",
            "descriptions": descriptions,
        }

    except ImportError as e:
        logger.error(f"ðŸŽ¨ [DEBUG] Import error: {e}")
        return {
            "success": False,
            "message": f"Visual narrator agent not available: {e}",
            "set_id": None,
            "descriptions": None,
        }
    except Exception as e:
        logger.error(f"ðŸŽ¨ [DEBUG] Error during test generation: {e}", exc_info=True)
        return {
            "success": False,
            "message": f"Generation failed: {e}",
            "set_id": None,
            "descriptions": None,
        }
