"""Scene Image Set storage for managing visual narrator generated images.

This module provides storage and tracking for sets of scene images generated
by the VisualNarratorAgent. Each set contains three images:
- Location & Ambiance
- Background Detail
- Moment Focus

Image sets are persisted as JSON files in the campaign's scene_image_sets folder,
allowing them to survive container restarts while maintaining the in-memory cache
for fast access during active sessions.
"""

import json
import logging
import uuid
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Literal, Optional

from gaia_private.session.session_storage import SessionStorage

logger = logging.getLogger(__name__)


class ImageType(str, Enum):
    """Scene image types generated by the Visual Narrator.

    Each scene image set contains three image types:
    - LOCATION_AMBIANCE: Wide establishing shot of the location
    - BACKGROUND_DETAIL: Environmental details and atmosphere
    - MOMENT_FOCUS: Key moment or action in the scene

    Note: This is distinct from ImageStorageType which determines
    the storage directory structure (portrait, scene, moment, etc.).
    """
    LOCATION_AMBIANCE = "location_ambiance"
    BACKGROUND_DETAIL = "background_detail"
    MOMENT_FOCUS = "moment_focus"

    @classmethod
    def all_types(cls) -> List[str]:
        """Return all image type values."""
        return [t.value for t in cls]


# Type aliases for backward compatibility
SceneImageType = Literal["location_ambiance", "background_detail", "moment_focus"]
SceneImageStatus = Literal["pending", "generating", "complete", "failed"]
SceneImageSetStatus = Literal["generating", "complete", "failed"]


@dataclass
class SceneImage:
    """Individual image within a scene image set."""

    image_type: SceneImageType
    description: str
    status: SceneImageStatus = "pending"
    image_path: Optional[str] = None
    image_url: Optional[str] = None
    error: Optional[str] = None
    generated_at: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for API response."""
        return {
            "type": self.image_type,
            "description": self.description,
            "status": self.status,
            "image_url": self.image_url,
            "image_path": self.image_path,
            "error": self.error,
            "generated_at": self.generated_at.isoformat() if self.generated_at else None,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SceneImage":
        """Create SceneImage from dictionary."""
        generated_at = None
        if data.get("generated_at"):
            try:
                generated_at = datetime.fromisoformat(data["generated_at"])
            except (ValueError, TypeError):
                pass
        return cls(
            image_type=data.get("type", data.get("image_type", "")),
            description=data.get("description", ""),
            status=data.get("status", "pending"),
            image_path=data.get("image_path"),
            image_url=data.get("image_url"),
            error=data.get("error"),
            generated_at=generated_at,
        )


@dataclass
class SceneImageSet:
    """A set of three scene images generated by the Visual Narrator.

    Tracks the generation status and results for location, background,
    and moment images for a single scene/turn.
    """

    set_id: str
    campaign_id: str
    turn_number: int
    status: SceneImageSetStatus = "generating"
    created_at: datetime = field(default_factory=datetime.utcnow)
    completed_at: Optional[datetime] = None
    images: List[SceneImage] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for API response and persistence."""
        return {
            "set_id": self.set_id,
            "campaign_id": self.campaign_id,
            "turn_number": self.turn_number,
            "status": self.status,
            "created_at": self.created_at.isoformat(),
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
            "images": [img.to_dict() for img in self.images],
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SceneImageSet":
        """Create SceneImageSet from dictionary."""
        created_at = datetime.utcnow()
        if data.get("created_at"):
            try:
                created_at = datetime.fromisoformat(data["created_at"])
            except (ValueError, TypeError):
                pass

        completed_at = None
        if data.get("completed_at"):
            try:
                completed_at = datetime.fromisoformat(data["completed_at"])
            except (ValueError, TypeError):
                pass

        images = [SceneImage.from_dict(img) for img in data.get("images", [])]

        return cls(
            set_id=data["set_id"],
            campaign_id=data["campaign_id"],
            turn_number=data.get("turn_number", 0),
            status=data.get("status", "generating"),
            created_at=created_at,
            completed_at=completed_at,
            images=images,
        )

    def update_status(self) -> None:
        """Update set status based on individual image statuses."""
        statuses = [img.status for img in self.images]

        if all(s == "complete" for s in statuses):
            self.status = "complete"
            self.completed_at = datetime.utcnow()
        elif any(s == "failed" for s in statuses) and not any(
            s in ("pending", "generating") for s in statuses
        ):
            # All done but some failed
            self.status = "failed"
            self.completed_at = datetime.utcnow()
        # Otherwise still generating

    def get_image(self, image_type: SceneImageType) -> Optional[SceneImage]:
        """Get a specific image by type."""
        for img in self.images:
            if img.image_type == image_type:
                return img
        return None


class SceneImageSetManager:
    """Manages scene image sets with persistence.

    Provides storage, retrieval, and status tracking for scene image sets.
    Sets are persisted as JSON files in the campaign's scene_image_sets folder.
    Maintains a limited number of sets per campaign to prevent unbounded growth.
    """

    MAX_SETS_PER_CAMPAIGN = 10  # Keep last N sets per campaign
    SETS_FOLDER = "scene_image_sets"

    def __init__(self) -> None:
        """Initialize the manager with empty in-memory cache."""
        self._sets: Dict[str, SceneImageSet] = {}  # set_id -> SceneImageSet
        self._campaign_sets: Dict[str, List[str]] = {}  # campaign_id -> [set_ids]
        self._loaded_campaigns: set[str] = set()  # Track which campaigns we've loaded
        self._storage = SessionStorage(ensure_legacy_dirs=True)

    def _get_sets_dir(self, campaign_id: str) -> Optional[Path]:
        """Get the scene_image_sets directory for a campaign."""
        campaign_dir = self._storage.resolve_session_dir(campaign_id, create=True)
        if not campaign_dir:
            return None
        sets_dir = campaign_dir / self.SETS_FOLDER
        sets_dir.mkdir(parents=True, exist_ok=True)
        return sets_dir

    def _persist_set(self, image_set: SceneImageSet) -> None:
        """Persist a scene image set to disk."""
        sets_dir = self._get_sets_dir(image_set.campaign_id)
        if not sets_dir:
            logger.warning(f"Could not get sets dir for campaign {image_set.campaign_id}")
            return

        set_file = sets_dir / f"{image_set.set_id}.json"
        try:
            with open(set_file, "w") as f:
                json.dump(image_set.to_dict(), f, indent=2)
            logger.debug(f"Persisted scene image set {image_set.set_id}")
        except Exception as e:
            logger.error(f"Failed to persist scene image set {image_set.set_id}: {e}")

    def _delete_set_file(self, campaign_id: str, set_id: str) -> None:
        """Delete a scene image set file from disk."""
        sets_dir = self._get_sets_dir(campaign_id)
        if not sets_dir:
            return

        set_file = sets_dir / f"{set_id}.json"
        try:
            if set_file.exists():
                set_file.unlink()
                logger.debug(f"Deleted scene image set file {set_id}")
        except Exception as e:
            logger.warning(f"Failed to delete scene image set file {set_id}: {e}")

    def _load_campaign_sets(self, campaign_id: str) -> None:
        """Load all scene image sets for a campaign from disk into memory."""
        if campaign_id in self._loaded_campaigns:
            return  # Already loaded

        sets_dir = self._get_sets_dir(campaign_id)
        if not sets_dir or not sets_dir.exists():
            self._loaded_campaigns.add(campaign_id)
            return

        loaded_sets: List[SceneImageSet] = []

        for set_file in sets_dir.glob("*.json"):
            try:
                with open(set_file) as f:
                    data = json.load(f)
                image_set = SceneImageSet.from_dict(data)
                loaded_sets.append(image_set)
            except Exception as e:
                logger.warning(f"Failed to load scene image set {set_file}: {e}")

        # Sort by created_at to maintain order
        loaded_sets.sort(key=lambda s: s.created_at)

        # Populate in-memory cache
        if campaign_id not in self._campaign_sets:
            self._campaign_sets[campaign_id] = []

        for image_set in loaded_sets:
            if image_set.set_id not in self._sets:
                self._sets[image_set.set_id] = image_set
                if image_set.set_id not in self._campaign_sets[campaign_id]:
                    self._campaign_sets[campaign_id].append(image_set.set_id)

        self._loaded_campaigns.add(campaign_id)
        logger.info(f"Loaded {len(loaded_sets)} scene image sets for campaign {campaign_id}")

    def create_set(
        self,
        campaign_id: str,
        turn_number: int,
        descriptions: Dict[str, str],
    ) -> SceneImageSet:
        """Create a new scene image set.

        Args:
            campaign_id: Campaign this set belongs to
            turn_number: Turn number when this set was created
            descriptions: Dict with location_ambiance, background_detail, moment_focus

        Returns:
            Created SceneImageSet
        """
        # Ensure campaign sets are loaded first
        self._load_campaign_sets(campaign_id)

        set_id = str(uuid.uuid4())

        images = [
            SceneImage(
                image_type=ImageType.LOCATION_AMBIANCE.value,
                description=descriptions.get(ImageType.LOCATION_AMBIANCE.value, ""),
                status="pending",
            ),
            SceneImage(
                image_type=ImageType.BACKGROUND_DETAIL.value,
                description=descriptions.get(ImageType.BACKGROUND_DETAIL.value, ""),
                status="pending",
            ),
            SceneImage(
                image_type=ImageType.MOMENT_FOCUS.value,
                description=descriptions.get(ImageType.MOMENT_FOCUS.value, ""),
                status="pending",
            ),
        ]

        image_set = SceneImageSet(
            set_id=set_id,
            campaign_id=campaign_id,
            turn_number=turn_number,
            status="generating",
            images=images,
        )

        self._sets[set_id] = image_set

        # Track by campaign
        if campaign_id not in self._campaign_sets:
            self._campaign_sets[campaign_id] = []
        self._campaign_sets[campaign_id].append(set_id)

        # Persist to disk
        self._persist_set(image_set)

        # Cleanup old sets
        self._cleanup_old_sets(campaign_id)

        logger.info(
            f"Created scene image set {set_id} for campaign {campaign_id} turn {turn_number}"
        )

        return image_set

    def get_set(self, set_id: str) -> Optional[SceneImageSet]:
        """Get a scene image set by ID.

        Args:
            set_id: The set ID to retrieve

        Returns:
            SceneImageSet if found, None otherwise
        """
        # First check in-memory cache
        if set_id in self._sets:
            return self._sets[set_id]

        # Try to find and load from disk if not in cache
        # We need to search all campaigns since we don't know which one it belongs to
        for session_id, campaign_dir, _ in self._storage.iter_session_dirs():
            sets_dir = campaign_dir / self.SETS_FOLDER
            set_file = sets_dir / f"{set_id}.json"
            if set_file.exists():
                try:
                    with open(set_file) as f:
                        data = json.load(f)
                    image_set = SceneImageSet.from_dict(data)
                    # Cache it
                    self._sets[set_id] = image_set
                    if session_id not in self._campaign_sets:
                        self._campaign_sets[session_id] = []
                    if set_id not in self._campaign_sets[session_id]:
                        self._campaign_sets[session_id].append(set_id)
                    return image_set
                except Exception as e:
                    logger.warning(f"Failed to load scene image set {set_id}: {e}")

        return None

    def get_latest_set(self, campaign_id: str) -> Optional[SceneImageSet]:
        """Get the most recent scene image set for a campaign.

        Args:
            campaign_id: Campaign to get latest set for

        Returns:
            Most recent SceneImageSet if any exist, None otherwise
        """
        # Ensure campaign sets are loaded
        self._load_campaign_sets(campaign_id)

        set_ids = self._campaign_sets.get(campaign_id, [])
        if not set_ids:
            return None

        # Return the most recent (last in list)
        latest_id = set_ids[-1]
        return self._sets.get(latest_id)

    def get_campaign_sets(
        self, campaign_id: str, limit: int = 5
    ) -> List[SceneImageSet]:
        """Get recent scene image sets for a campaign.

        Args:
            campaign_id: Campaign to get sets for
            limit: Maximum number of sets to return

        Returns:
            List of SceneImageSets, most recent first
        """
        # Ensure campaign sets are loaded
        self._load_campaign_sets(campaign_id)

        set_ids = self._campaign_sets.get(campaign_id, [])

        # Return most recent first
        recent_ids = set_ids[-limit:][::-1]
        return [self._sets[sid] for sid in recent_ids if sid in self._sets]

    def update_image(
        self,
        set_id: str,
        image_type: SceneImageType,
        status: SceneImageStatus,
        image_path: Optional[str] = None,
        image_url: Optional[str] = None,
        error: Optional[str] = None,
    ) -> Optional[SceneImageSet]:
        """Update an individual image within a set.

        Args:
            set_id: The set containing the image
            image_type: Which image to update
            status: New status
            image_path: Path to generated image (if complete)
            image_url: URL to generated image (if complete)
            error: Error message (if failed)

        Returns:
            Updated SceneImageSet if found, None otherwise
        """
        image_set = self.get_set(set_id)  # This will load from disk if needed
        if not image_set:
            logger.warning(f"Scene image set {set_id} not found for update")
            return None

        image = image_set.get_image(image_type)
        if not image:
            logger.warning(f"Image type {image_type} not found in set {set_id}")
            return None

        image.status = status
        image.image_path = image_path
        image.image_url = image_url
        image.error = error

        if status == "complete":
            image.generated_at = datetime.utcnow()

        # Update set status
        image_set.update_status()

        # Persist updated set to disk
        self._persist_set(image_set)

        logger.info(
            f"Updated {image_type} in set {set_id}: status={status}, "
            f"set_status={image_set.status}"
        )

        return image_set

    def _cleanup_old_sets(self, campaign_id: str) -> None:
        """Remove old sets beyond the max limit.

        Args:
            campaign_id: Campaign to clean up
        """
        set_ids = self._campaign_sets.get(campaign_id, [])

        while len(set_ids) > self.MAX_SETS_PER_CAMPAIGN:
            old_id = set_ids.pop(0)
            if old_id in self._sets:
                del self._sets[old_id]
                self._delete_set_file(campaign_id, old_id)
                logger.debug(f"Cleaned up old scene image set {old_id}")


# Global singleton instance
_scene_image_set_manager: Optional[SceneImageSetManager] = None


def get_scene_image_set_manager() -> SceneImageSetManager:
    """Get the global SceneImageSetManager instance.

    Returns:
        Global SceneImageSetManager singleton
    """
    global _scene_image_set_manager
    if _scene_image_set_manager is None:
        _scene_image_set_manager = SceneImageSetManager()
    return _scene_image_set_manager
