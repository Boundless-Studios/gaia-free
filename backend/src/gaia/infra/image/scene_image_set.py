"""Scene Image Set storage for managing visual narrator generated images.

This module provides storage and tracking for sets of scene images generated
by the VisualNarratorAgent. Each set contains three images:
- Location & Ambiance
- Background Detail
- Moment Focus

Image sets are tracked in-memory with metadata persistence, allowing the
frontend to poll for generation status and retrieve completed images.
"""

import logging
import uuid
from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Literal, Optional

logger = logging.getLogger(__name__)

SceneImageType = Literal["location_ambiance", "background_detail", "moment_focus"]
SceneImageStatus = Literal["pending", "generating", "complete", "failed"]
SceneImageSetStatus = Literal["generating", "complete", "failed"]


@dataclass
class SceneImage:
    """Individual image within a scene image set."""

    image_type: SceneImageType
    description: str
    status: SceneImageStatus = "pending"
    image_path: Optional[str] = None
    image_url: Optional[str] = None
    error: Optional[str] = None
    generated_at: Optional[datetime] = None

    def to_dict(self) -> Dict:
        """Convert to dictionary for API response."""
        return {
            "type": self.image_type,
            "description": self.description,
            "status": self.status,
            "image_url": self.image_url,
            "image_path": self.image_path,
            "error": self.error,
            "generated_at": self.generated_at.isoformat() if self.generated_at else None,
        }


@dataclass
class SceneImageSet:
    """A set of three scene images generated by the Visual Narrator.

    Tracks the generation status and results for location, background,
    and moment images for a single scene/turn.
    """

    set_id: str
    campaign_id: str
    turn_number: int
    status: SceneImageSetStatus = "generating"
    created_at: datetime = field(default_factory=datetime.utcnow)
    completed_at: Optional[datetime] = None
    images: List[SceneImage] = field(default_factory=list)

    def to_dict(self) -> Dict:
        """Convert to dictionary for API response."""
        return {
            "set_id": self.set_id,
            "campaign_id": self.campaign_id,
            "turn_number": self.turn_number,
            "status": self.status,
            "created_at": self.created_at.isoformat(),
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
            "images": [img.to_dict() for img in self.images],
        }

    def update_status(self) -> None:
        """Update set status based on individual image statuses."""
        statuses = [img.status for img in self.images]

        if all(s == "complete" for s in statuses):
            self.status = "complete"
            self.completed_at = datetime.utcnow()
        elif any(s == "failed" for s in statuses) and not any(
            s in ("pending", "generating") for s in statuses
        ):
            # All done but some failed
            self.status = "failed"
            self.completed_at = datetime.utcnow()
        # Otherwise still generating

    def get_image(self, image_type: SceneImageType) -> Optional[SceneImage]:
        """Get a specific image by type."""
        for img in self.images:
            if img.image_type == image_type:
                return img
        return None


class SceneImageSetManager:
    """Manages scene image sets with in-memory storage.

    Provides storage, retrieval, and status tracking for scene image sets.
    Maintains a limited number of sets per campaign to prevent unbounded growth.
    """

    MAX_SETS_PER_CAMPAIGN = 10  # Keep last N sets per campaign

    def __init__(self):
        """Initialize the manager with empty storage."""
        self._sets: Dict[str, SceneImageSet] = {}  # set_id -> SceneImageSet
        self._campaign_sets: Dict[str, List[str]] = {}  # campaign_id -> [set_ids]

    def create_set(
        self,
        campaign_id: str,
        turn_number: int,
        descriptions: Dict[str, str],
    ) -> SceneImageSet:
        """Create a new scene image set.

        Args:
            campaign_id: Campaign this set belongs to
            turn_number: Turn number when this set was created
            descriptions: Dict with location_ambiance, background_detail, moment_focus

        Returns:
            Created SceneImageSet
        """
        set_id = str(uuid.uuid4())

        images = [
            SceneImage(
                image_type="location_ambiance",
                description=descriptions.get("location_ambiance", ""),
                status="pending",
            ),
            SceneImage(
                image_type="background_detail",
                description=descriptions.get("background_detail", ""),
                status="pending",
            ),
            SceneImage(
                image_type="moment_focus",
                description=descriptions.get("moment_focus", ""),
                status="pending",
            ),
        ]

        image_set = SceneImageSet(
            set_id=set_id,
            campaign_id=campaign_id,
            turn_number=turn_number,
            status="generating",
            images=images,
        )

        self._sets[set_id] = image_set

        # Track by campaign
        if campaign_id not in self._campaign_sets:
            self._campaign_sets[campaign_id] = []
        self._campaign_sets[campaign_id].append(set_id)

        # Cleanup old sets
        self._cleanup_old_sets(campaign_id)

        logger.info(
            f"Created scene image set {set_id} for campaign {campaign_id} turn {turn_number}"
        )

        return image_set

    def get_set(self, set_id: str) -> Optional[SceneImageSet]:
        """Get a scene image set by ID.

        Args:
            set_id: The set ID to retrieve

        Returns:
            SceneImageSet if found, None otherwise
        """
        return self._sets.get(set_id)

    def get_latest_set(self, campaign_id: str) -> Optional[SceneImageSet]:
        """Get the most recent scene image set for a campaign.

        Args:
            campaign_id: Campaign to get latest set for

        Returns:
            Most recent SceneImageSet if any exist, None otherwise
        """
        set_ids = self._campaign_sets.get(campaign_id, [])
        if not set_ids:
            return None

        # Return the most recent (last in list)
        latest_id = set_ids[-1]
        return self._sets.get(latest_id)

    def get_campaign_sets(
        self, campaign_id: str, limit: int = 5
    ) -> List[SceneImageSet]:
        """Get recent scene image sets for a campaign.

        Args:
            campaign_id: Campaign to get sets for
            limit: Maximum number of sets to return

        Returns:
            List of SceneImageSets, most recent first
        """
        set_ids = self._campaign_sets.get(campaign_id, [])

        # Return most recent first
        recent_ids = set_ids[-limit:][::-1]
        return [self._sets[sid] for sid in recent_ids if sid in self._sets]

    def update_image(
        self,
        set_id: str,
        image_type: SceneImageType,
        status: SceneImageStatus,
        image_path: Optional[str] = None,
        image_url: Optional[str] = None,
        error: Optional[str] = None,
    ) -> Optional[SceneImageSet]:
        """Update an individual image within a set.

        Args:
            set_id: The set containing the image
            image_type: Which image to update
            status: New status
            image_path: Path to generated image (if complete)
            image_url: URL to generated image (if complete)
            error: Error message (if failed)

        Returns:
            Updated SceneImageSet if found, None otherwise
        """
        image_set = self._sets.get(set_id)
        if not image_set:
            logger.warning(f"Scene image set {set_id} not found for update")
            return None

        image = image_set.get_image(image_type)
        if not image:
            logger.warning(f"Image type {image_type} not found in set {set_id}")
            return None

        image.status = status
        image.image_path = image_path
        image.image_url = image_url
        image.error = error

        if status == "complete":
            image.generated_at = datetime.utcnow()

        # Update set status
        image_set.update_status()

        logger.info(
            f"Updated {image_type} in set {set_id}: status={status}, "
            f"set_status={image_set.status}"
        )

        return image_set

    def _cleanup_old_sets(self, campaign_id: str) -> None:
        """Remove old sets beyond the max limit.

        Args:
            campaign_id: Campaign to clean up
        """
        set_ids = self._campaign_sets.get(campaign_id, [])

        while len(set_ids) > self.MAX_SETS_PER_CAMPAIGN:
            old_id = set_ids.pop(0)
            if old_id in self._sets:
                del self._sets[old_id]
                logger.debug(f"Cleaned up old scene image set {old_id}")


# Global singleton instance
_scene_image_set_manager: Optional[SceneImageSetManager] = None


def get_scene_image_set_manager() -> SceneImageSetManager:
    """Get the global SceneImageSetManager instance.

    Returns:
        Global SceneImageSetManager singleton
    """
    global _scene_image_set_manager
    if _scene_image_set_manager is None:
        _scene_image_set_manager = SceneImageSetManager()
    return _scene_image_set_manager
