import React, { useState, useEffect, useCallback, useRef } from 'react';
import { API_CONFIG } from '../config/api.js';
import './SceneImagesMiniGallery.css';

/**
 * Mini gallery component for displaying scene images generated by the Visual Narrator.
 * Shows 3 vertically stacked preview thumbnails with status indicators.
 * Allows DM to send a composite image to players.
 */
const SceneImagesMiniGallery = ({
  campaignId,
  onShowToPlayers = null,
  pollingInterval = 5000,
  className = '',
  refreshTrigger = null,  // Socket-triggered refresh
}) => {
  const [imageSet, setImageSet] = useState(null);
  const [isCreatingComposite, setIsCreatingComposite] = useState(false);
  const pollingIntervalRef = useRef(null);
  const [isVisible, setIsVisible] = useState(true);

  // Fetch latest scene images
  const fetchLatestImages = useCallback(async () => {
    if (!campaignId) return;

    try {
      const response = await fetch(
        `${API_CONFIG.BACKEND_URL}/api/scene-images/latest?campaign_id=${encodeURIComponent(campaignId)}`,
        {
          headers: {
            'Content-Type': 'application/json',
          },
        }
      );

      if (response.ok) {
        const data = await response.json();
        if (data) {
          setImageSet(data);
        }
      } else if (response.status === 404) {
        // No images yet, that's fine
        setImageSet(null);
      }
    } catch (error) {
      console.error('Error fetching scene images:', error);
    }
  }, [campaignId]);

  // Set up polling
  useEffect(() => {
    if (!campaignId || !isVisible) return;

    // Initial fetch
    fetchLatestImages();

    // Set up polling
    pollingIntervalRef.current = setInterval(() => {
      // Only poll if we're still generating or don't have images
      if (!imageSet || imageSet.status === 'generating') {
        fetchLatestImages();
      }
    }, pollingInterval);

    return () => {
      if (pollingIntervalRef.current) {
        clearInterval(pollingIntervalRef.current);
      }
    };
  }, [campaignId, isVisible, pollingInterval, fetchLatestImages, imageSet?.status]);

  // Handle visibility change
  useEffect(() => {
    const handleVisibilityChange = () => {
      setIsVisible(document.visibilityState === 'visible');
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, []);

  // Instant refresh when socket event triggers
  useEffect(() => {
    if (refreshTrigger) {
      console.log('ðŸ–¼ï¸ SceneImagesMiniGallery: Socket refresh triggered');
      fetchLatestImages();
    }
  }, [refreshTrigger, fetchLatestImages]);

  // Handle clicking on an image - show in main App modal
  const handleImageClick = useCallback((image) => {
    if (onShowToPlayers && image.image_url) {
      // Use same format as ImageGalleryWithPolling for consistency
      onShowToPlayers({
        generated_image_url: `${API_CONFIG.BACKEND_URL}${image.image_url}`,
        generated_image_path: image.image_url,
        generated_image_prompt: image.description,
        generated_image_type: 'scene'
      });
    }
  }, [onShowToPlayers]);

  // Handle creating and sending composite image to players
  const handleSendCompositeToPlayers = useCallback(async () => {
    if (!imageSet || !onShowToPlayers) return;

    setIsCreatingComposite(true);
    try {
      const response = await fetch(
        `${API_CONFIG.BACKEND_URL}/api/scene-images/${imageSet.set_id}/composite`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
        }
      );

      if (response.ok) {
        const data = await response.json();
        if (data.success && data.composite_url) {
          // Send the composite image URL to players - use same format as ImageGalleryWithPolling
          onShowToPlayers({
            generated_image_url: `${API_CONFIG.BACKEND_URL}${data.composite_url}`,
            generated_image_path: data.composite_url,
            generated_image_prompt: 'Scene Composite Image',
            generated_image_type: 'scene'
          });
        } else {
          console.error('Failed to create composite:', data.message);
        }
      } else {
        console.error('Failed to create composite image:', response.statusText);
      }
    } catch (error) {
      console.error('Error creating composite image:', error);
    } finally {
      setIsCreatingComposite(false);
    }
  }, [imageSet, onShowToPlayers]);

  // Render image thumbnail
  const renderImageThumbnail = (image) => {
    const isComplete = image.status === 'complete';
    const isFailed = image.status === 'failed';
    const isGenerating = image.status === 'generating' || image.status === 'pending';

    const typeLabels = {
      location_ambiance: 'Location',
      background_detail: 'Background',
      moment_focus: 'Moment',
    };

    return (
      <div
        key={image.type}
        className={`scene-image-card ${isComplete ? 'complete' : ''}`}
        onClick={() => isComplete && handleImageClick(image)}
      >
        <div className={`scene-image-thumbnail ${isComplete ? 'complete' : ''} ${isFailed ? 'failed' : ''}`}>
          {isGenerating && (
            <div className="thumbnail-generating">
              <div className="spinner" />
              <span className="label">{typeLabels[image.type] || image.type}</span>
            </div>
          )}

          {isFailed && (
            <div className="thumbnail-failed">
              <span className="icon">!</span>
              <span className="label">{typeLabels[image.type] || image.type}</span>
            </div>
          )}

          {isComplete && image.image_url && (
            <>
              <img
                src={`${API_CONFIG.BACKEND_URL}${image.image_url}`}
                alt={image.description || typeLabels[image.type]}
                loading="lazy"
              />
              <div className="thumbnail-overlay">
                <span className="label">{typeLabels[image.type] || image.type}</span>
              </div>
            </>
          )}
        </div>
      </div>
    );
  };

  // If no campaign, don't render
  if (!campaignId) return null;

  const hasImages = imageSet && imageSet.images.length > 0;
  const completedCount = hasImages
    ? imageSet.images.filter(img => img.status === 'complete').length
    : 0;
  const canSendToPlayers = completedCount > 0 && onShowToPlayers && !isCreatingComposite;

  return (
    <div className={`scene-images-mini-gallery ${className}`}>
      {/* Clickable header - matches Turn header styling */}
      <div
        className={`gallery-header ${canSendToPlayers ? 'clickable' : ''} ${isCreatingComposite ? 'sending' : ''} ${!hasImages ? 'disabled' : ''}`}
        onClick={canSendToPlayers ? handleSendCompositeToPlayers : undefined}
        title={canSendToPlayers ? 'Click to send composite image to players' : (!hasImages ? 'No scene images available' : undefined)}
      >
        <span className="header-label">
          {isCreatingComposite ? 'Sending...' : (hasImages ? 'Click to Send' : 'Scene Images')}
        </span>
      </div>

      {hasImages ? (
        <div className="thumbnails-container">
          {imageSet.images.map((image) => renderImageThumbnail(image))}
        </div>
      ) : (
        <div className="empty-state">
          <span className="empty-message">No scene images available</span>
        </div>
      )}
    </div>
  );
};

export default SceneImagesMiniGallery;
