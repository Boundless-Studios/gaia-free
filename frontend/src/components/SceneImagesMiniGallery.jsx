import React, { useState, useEffect, useCallback, useRef } from 'react';
import { API_CONFIG } from '../config/api.js';
import { Button } from './base-ui/Button';
import './SceneImagesMiniGallery.css';

/**
 * Mini gallery component for displaying scene images generated by the Visual Narrator.
 * Shows 3 small preview thumbnails with status indicators.
 * Allows DM to show images to players.
 */
const SceneImagesMiniGallery = ({
  campaignId,
  onShowToPlayers = null,
  pollingInterval = 5000,
  className = ''
}) => {
  const [imageSet, setImageSet] = useState(null);
  const [selectedImage, setSelectedImage] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const pollingIntervalRef = useRef(null);
  const [isVisible, setIsVisible] = useState(true);

  // Fetch latest scene images
  const fetchLatestImages = useCallback(async () => {
    if (!campaignId) return;

    try {
      const response = await fetch(
        `${API_CONFIG.BACKEND_URL}/api/scene-images/latest?campaign_id=${encodeURIComponent(campaignId)}`,
        {
          headers: {
            'Content-Type': 'application/json',
          },
        }
      );

      if (response.ok) {
        const data = await response.json();
        if (data) {
          setImageSet(data);
        }
      } else if (response.status === 404) {
        // No images yet, that's fine
        setImageSet(null);
      }
    } catch (error) {
      console.error('Error fetching scene images:', error);
    }
  }, [campaignId]);

  // Set up polling - only when actively generating
  useEffect(() => {
    if (!campaignId || !isVisible) return;

    // Initial fetch
    fetchLatestImages();

    // Only set up polling if we're actively generating (not when null/404)
    // This prevents continuous polling when no scene images exist
    if (imageSet?.status === 'generating') {
      pollingIntervalRef.current = setInterval(() => {
        fetchLatestImages();
      }, pollingInterval);
    }

    return () => {
      if (pollingIntervalRef.current) {
        clearInterval(pollingIntervalRef.current);
      }
    };
  }, [campaignId, isVisible, pollingInterval, fetchLatestImages, imageSet?.status]);

  // Handle visibility change
  useEffect(() => {
    const handleVisibilityChange = () => {
      setIsVisible(document.visibilityState === 'visible');
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, []);

  // Handle showing image to players
  const handleShowToPlayers = useCallback((image) => {
    if (onShowToPlayers && image.image_url) {
      onShowToPlayers(image.image_url);
    }
  }, [onShowToPlayers]);

  // Handle showing all images
  const handleShowAllToPlayers = useCallback(() => {
    if (!imageSet || !onShowToPlayers) return;

    // Show each image that's complete
    imageSet.images
      .filter(img => img.status === 'complete' && img.image_url)
      .forEach(img => {
        onShowToPlayers(img.image_url);
      });
  }, [imageSet, onShowToPlayers]);

  // Render image thumbnail
  const renderImageThumbnail = (image, index) => {
    const isComplete = image.status === 'complete';
    const isFailed = image.status === 'failed';
    const isGenerating = image.status === 'generating' || image.status === 'pending';

    const typeLabels = {
      location_ambiance: 'Location',
      background_detail: 'Background',
      moment_focus: 'Moment',
    };

    return (
      <div
        key={image.type}
        className={`scene-image-thumbnail ${isComplete ? 'complete' : ''} ${isFailed ? 'failed' : ''}`}
        onClick={() => isComplete && setSelectedImage(image)}
      >
        {isGenerating && (
          <div className="thumbnail-generating">
            <div className="spinner" />
            <span className="label">{typeLabels[image.type] || image.type}</span>
          </div>
        )}

        {isFailed && (
          <div className="thumbnail-failed">
            <span className="icon">!</span>
            <span className="label">{typeLabels[image.type] || image.type}</span>
          </div>
        )}

        {isComplete && image.image_url && (
          <>
            <img
              src={`${API_CONFIG.BACKEND_URL}${image.image_url}`}
              alt={image.description || typeLabels[image.type]}
              loading="lazy"
            />
            <div className="thumbnail-overlay">
              <span className="label">{typeLabels[image.type] || image.type}</span>
            </div>
          </>
        )}
      </div>
    );
  };

  // If no campaign or no images, show nothing
  if (!campaignId) return null;
  if (!imageSet || imageSet.images.length === 0) {
    return null; // Don't show empty state, just hide
  }

  const completedCount = imageSet.images.filter(img => img.status === 'complete').length;
  const isAllComplete = imageSet.status === 'complete';

  return (
    <div className={`scene-images-mini-gallery ${className}`}>
      <div className="gallery-header">
        <span className="title">Scene Images</span>
        {isAllComplete && completedCount > 0 && onShowToPlayers && (
          <Button
            size="sm"
            variant="secondary"
            onClick={handleShowAllToPlayers}
          >
            Show All
          </Button>
        )}
      </div>

      <div className="thumbnails-container">
        {imageSet.images.map((image, index) => renderImageThumbnail(image, index))}
      </div>

      {/* Enlarged image modal */}
      {selectedImage && (
        <div className="image-modal" onClick={() => setSelectedImage(null)}>
          <div className="modal-content" onClick={(e) => e.stopPropagation()}>
            <img
              src={`${API_CONFIG.BACKEND_URL}${selectedImage.image_url}`}
              alt={selectedImage.description}
            />
            <div className="modal-info">
              <p className="description">{selectedImage.description}</p>
              <div className="modal-actions">
                {onShowToPlayers && (
                  <Button
                    variant="primary"
                    onClick={() => {
                      handleShowToPlayers(selectedImage);
                      setSelectedImage(null);
                    }}
                  >
                    Show to Players
                  </Button>
                )}
                <Button
                  variant="secondary"
                  onClick={() => setSelectedImage(null)}
                >
                  Close
                </Button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default SceneImagesMiniGallery;
